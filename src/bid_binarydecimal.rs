/* -------------------------------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------------------------------- */
/* Port of the Intel Decimal Floating-Point Math Library decimal128 type to Rust.                     */
/* decmathlib-rs - Copyright (C) 2023-2024 Carlos Guzmán Álvarez                                      */
/* -------------------------------------------------------------------------------------------------- */
/* Licensed under the MIT license. See LICENSE file in the project root for full license information. */
/* -------------------------------------------------------------------------------------------------- */
/* Intel® Decimal Floating-Point Math Library - Copyright (c) 2018, Intel Corp.                       */
/* -------------------------------------------------------------------------------------------------- */

use crate::bid_internal::*;
use crate::d128::{_IDEC_flags, RoundingMode, StatusFlags};

// Counting leading zeros in an unsigned 32-bit word
// The "_nz" version will return the wrong answer (31) for zero inputs

const CLZ32_MASK16: u32 = 0xFFFF0000u32;
const CLZ32_MASK8:  u32 = 0xFF00FF00u32;
const CLZ32_MASK4:  u32 = 0xF0F0F0F0u32;
const CLZ32_MASK2:  u32 = 0xCCCCCCCCu32;
const CLZ32_MASK1:  u32 = 0xAAAAAAAAu32;

fn clz32_nz(n: u32) -> u32 {
    let x1 = if (n & CLZ32_MASK16) <= (n & !CLZ32_MASK16) { 16 } else { 0 };
    let x2 = if (n & CLZ32_MASK8)  <= (n & !CLZ32_MASK8)  {  8 } else { 0 };
    let x3 = if (n & CLZ32_MASK4)  <= (n & !CLZ32_MASK4)  {  4 } else { 0 };
    let x4 = if (n & CLZ32_MASK2)  <= (n & !CLZ32_MASK2)  {  2 } else { 0 };
    let x5 = if (n & CLZ32_MASK1)  <= (n & !CLZ32_MASK1)  {  1 } else { 0 };

    x1 + x2 + x3 + x4 + x5
}

fn clz32(n: u32) -> u32 {
    if n == 0 { 32 } else { clz32_nz(n) }
}

// Counting trailing zeros in an unsigned 32-bit word
// The ctz32_1bit version is for a single bit

fn ctz32_1bit(n: u32) -> u32 {
    let x1 = if (n & !CLZ32_MASK16) != 0 { 0 } else { 16 };
    let x2 = if (n & !CLZ32_MASK8)  != 0 { 0 } else {  8 };
    let x3 = if (n & !CLZ32_MASK4)  != 0 { 0 } else {  4 };
    let x4 = if (n & !CLZ32_MASK2)  != 0 { 0 } else {  2 };
    let x5 = if (n & !CLZ32_MASK1)  != 0 { 0 } else {  1 };

    x1 + x2 + x3 + x4 + x5
}

fn ctz32(n: i32) -> u32 {
    if n == 0 { 32 } else { ctz32_1bit((n & -n) as u32) }
}

// Counting leading zeros in an unsigned 64-bit word
// The "_nz" version will return the wrong answer (63) for zero inputs

const CLZ64_MASK32 : u64 = 0xFFFFFFFF00000000u64;
const CLZ64_MASK16 : u64 = 0xFFFF0000FFFF0000u64;
const CLZ64_MASK8  : u64 = 0xFF00FF00FF00FF00u64;
const CLZ64_MASK4  : u64 = 0xF0F0F0F0F0F0F0F0u64;
const CLZ64_MASK2  : u64 = 0xCCCCCCCCCCCCCCCCu64;
const CLZ64_MASK1  : u64 = 0xAAAAAAAAAAAAAAAAu64;

fn clz64_nz(n: u64) -> u64 {
    let x1 = if (n & CLZ64_MASK32) <= (n & !CLZ64_MASK32) { 32 } else { 0 };
    let x2 = if (n & CLZ64_MASK16) <= (n & !CLZ64_MASK16) { 16 } else { 0 };
    let x3 = if (n & CLZ64_MASK8)  <= (n & !CLZ64_MASK8)  {  8 } else { 0 };
    let x4 = if (n & CLZ64_MASK4)  <= (n & !CLZ64_MASK4)  {  4 } else { 0 };
    let x5 = if (n & CLZ64_MASK2)  <= (n & !CLZ64_MASK2)  {  2 } else { 0 };
    let x6 = if (n & CLZ64_MASK1)  <= (n & !CLZ64_MASK1)  {  1 } else { 0 };

    x1 + x2 + x3 + x4 + x5 + x6
}

fn clz64(n: u64) -> u64 {
    if n == 0 { 64 } else { clz64_nz(n) }
}

// Counting trailing zeros in an unsigned 64-bit word
// The ctz64_1bit version is for a single bit

fn ctz64_1bit(n: u64) -> u64 {
    let x1 = if (n & !CLZ64_MASK32) != 0 { 0 } else { 32 };
    let x2 = if (n & !CLZ64_MASK16) != 0 { 0 } else { 16 };
    let x3 = if (n & !CLZ64_MASK8)  != 0 { 0 } else {  8 };
    let x4 = if (n & !CLZ64_MASK4)  != 0 { 0 } else {  4 };
    let x5 = if (n & !CLZ64_MASK2)  != 0 { 0 } else {  2 };
    let x6 = if (n & !CLZ64_MASK1)  != 0 { 0 } else {  1 };

    x1 + x2 + x3 + x4 + x5 + x6
}

fn ctz64(n: i64) -> u64 {
    if n == 0 { 64 } else { ctz64_1bit((n & -n) as u64) }
}

// Shift 2-part 2^64 * hi + lo right by "c" bits
// The "short" form requires a shift 0 < c < 64 and will be faster
// Note that shifts of 64 can't be relied on as ANSI

fn srl128_short(hi: u64, lo: u64, c: u64) -> (u64, u64) {
    (hi >> c, ((hi) << (64 - (c))) + ((lo) >> (c)))
}

fn srl128(hi: u64, lo: u64, c: u64) -> (u64, u64) {
    if c == 0 {
        (hi, lo)
    } else if c >= 64 {
        (0, hi >> (c - 64))
    } else {
        srl128_short(hi, lo, c)
    }
}

// Similarly for 6-part result

fn srl384_short(x: &mut BID_UINT512, c: i32) {
    x.w[0]   = (x.w[1] << (64 - c)) + (x.w[0] >> c);
    x.w[1]   = (x.w[2] << (64 - c)) + (x.w[1] >> c);
    x.w[2]   = (x.w[3] << (64 - c)) + (x.w[2] >> c);
    x.w[3]   = (x.w[4] << (64 - c)) + (x.w[3] >> c);
    x.w[4]   = (x.w[5] << (64 - c)) + (x.w[4] >> c);
    x.w[5] >>= c;
}

// Compare "<" two 2-part unsigned integers

fn lt128(x_hi: u64, x_lo: u64, y_hi: u64, y_lo: u64) -> bool {
    ((x_hi) < (y_hi)) || (((x_hi) == (y_hi)) && ((x_lo) < (y_lo)))
}

// Likewise "<="

fn le128(x_hi: u64, x_lo: u64, y_hi: u64, y_lo: u64) -> bool {
    ((x_hi) < (y_hi)) || (((x_hi) == (y_hi)) && ((x_lo) <= (y_lo)))
}

// 128x256->384 bit multiplication (missing from existing macros)
// I derived this by propagating (A).w[2] = 0 in __mul_192x256_to_448

fn __mul_128x256_to_384(A: &BID_UINT128, B: &BID_UINT256) -> BID_UINT512 {
    let mut P: BID_UINT512 = Default::default();
    let mut CY: BID_UINT64;
    let P0: BID_UINT512 = __mul_64x256_to_320(A.w[0], B);
    let P1: BID_UINT512 = __mul_64x256_to_320(A.w[1], B);
    P.w[0] = P0.w[0];
    (P.w[1], CY) = __add_carry_out(P1.w[0],P0.w[1]);
    (P.w[2], CY) = __add_carry_in_out(P1.w[1],P0.w[2], CY);
    (P.w[3], CY) = __add_carry_in_out(P1.w[2],P0.w[3], CY);
    (P.w[4], CY) = __add_carry_in_out(P1.w[3],P0.w[4], CY);
    P.w[5] = P1.w[4] + CY;
    P
}

// Multiply a 64-bit number by 10, getting "carry" and "sum"

fn __mul_10x64(sum: &mut u64, carryout: &mut u64, input: u64, carryin: u64) {
    let mut s3: u64 = input + ((input) >> 2);
    *carryout = ((if s3 < (input) { 1 } else { 0 }) << 3) + (s3 >> 61);
    s3        = (s3 << 3) + ((input & 3) << 1);
    *sum      = s3 + (carryin);
    if *sum < s3 { *carryout += 1 }
}

// Likewise a 384-bit number

fn __mul_10x384_to_384(p: &mut BID_UINT512) {
    let a: BID_UINT512 = p.clone();
    let mut c0: u64 = 0;
    let mut c1: u64 = 0;
    let mut c2: u64 = 0;
    let mut c3: u64 = 0;
    let mut c4: u64 = 0;
    let mut c5: u64 = 0;
    __mul_10x64(&mut p.w[0], &mut c0, a.w[0],0u64);
    __mul_10x64(&mut p.w[1], &mut c1, a.w[1], c0);
    __mul_10x64(&mut p.w[2], &mut c2, a.w[2], c1);
    __mul_10x64(&mut p.w[3], &mut c3, a.w[3], c2);
    __mul_10x64(&mut p.w[4], &mut c4, a.w[4], c3);
    __mul_10x64(&mut p.w[5], &mut c5, a.w[5], c4);
}

// Unpack binary floating-point number x into
//
// int    s (sign in the LSB)
// int    e (true "integer" exponent)
//        c (normalized coefficient with explicit 1 bit)
//        t (trailing zero count, valid in normalized case only)
//        [c_hi,c_lo in the case of quad]
//
// Call the given zero, infinity or nan macros if appropriate

fn unpack_binary32(x: f32, s: &mut i32, e: &mut i32, c: &mut BID_UINT64, t: &mut i32, zero: &dyn Fn(i32) -> BID_UINT128, inf: &dyn Fn(i32) -> BID_UINT128, nan: &dyn Fn(i32, u64, u64) -> BID_UINT128, pfpsf: &mut _IDEC_flags) -> Option<BID_UINT128> {
    unsafe {
        let mut x_in: BID_UI32FLOAT = Default::default();
        x_in.d = x;
        *c     = x_in.ui32 as BID_UINT64;
        *e     = ((*c >> 23) & ((1u64 << 8) - 1)) as i32;
        *s     = (*c >> 31) as i32;
        *c    &= (1u64 << 23) - 1;
        if *e == 0 {
            let l: i32;
            if *c == 0 {
                return Some(zero(*s));
            }
            l    = (clz32(*c as u32) - (32 - 24)) as i32;
            *c <<= l;
            *e   = -(l + 149);
            *t   = 0;
            __set_status_flags(pfpsf, StatusFlags::BID_DENORMAL_EXCEPTION);
        } else if (*e as u64) == ((1u64 << 8) - 1) {
            if *c == 0 {
                return Some(inf(*s));
            }
            if (*c & (1u64 << 22)) == 0 {
                __set_status_flags(pfpsf, StatusFlags::BID_INVALID_EXCEPTION);
            }
            return Some(nan(*s, *c << 42, 0u64));
         } else {
            *c += 1u64 << 23;
            *t = ctz32(*c as i32) as i32;
            *e -= 150;
         }

        None
    }
}

fn unpack_binary64(x: f64, s: &mut i32, e: &mut i32, c: &mut BID_UINT64, t: &mut i32, zero: &dyn Fn(i32) -> BID_UINT128, inf: &dyn Fn(i32) -> BID_UINT128, nan: &dyn Fn(i32, u64, u64) -> BID_UINT128, pfpsf: &mut _IDEC_flags) -> Option<BID_UINT128> {
    unsafe {
        let mut x_in: BID_UI64DOUBLE = Default::default();

        x_in.d = x;
        *c     = x_in.ui64;
        *e     = ((*c >> 52) & ((1u64 << 11) - 1)) as i32;
        *s     =  (*c >> 63) as i32;
        *c    &= (1u64 << 52) - 1;
        if *e == 0 {
            if *c == 0 {
                return Some(zero(*s));
            }
            let l = (clz64(*c) - (64 - 53)) as i32;
            *c <<= l;
            *e   = -(l + 1074);
            *t   = 0;
            __set_status_flags(pfpsf,StatusFlags::BID_DENORMAL_EXCEPTION);
        } else if (*e as u64) == ((1u64 << 11) - 1) {
            if *c == 0 {
                return Some(inf(*s));
            }
            if (*c & (1u64 << 51)) ==0 {
                __set_status_flags(pfpsf, StatusFlags::BID_INVALID_EXCEPTION);
            }
            return Some(nan(*s, *c << 13, 0u64));
        } else {
            *c += 1u64 << 52;
            *t = ctz64(*c as i64) as i32;
            *e -= 1075;
        }

        None
    }
}

fn return_bid128(s: i32, e: i32, c_hi: u64, c_lo: u64) -> BID_UINT128 {
    let mut x_out: BID_UINT128 = Default::default();
    x_out.w[BID_LOW_128W]  = c_lo;
    x_out.w[BID_HIGH_128W] = ((s as BID_UINT64) << 63) + ((e as BID_UINT64) << 49) + (c_hi);
    x_out
}

fn return_bid128_zero(s: i32) -> BID_UINT128 {
    return_bid128(s, 6176, 0, 0)
}

fn return_bid128_inf(s: i32) -> BID_UINT128 {
    return_bid128(s, 0xF << 10, 0, 0)
}

fn return_bid128_nan(s: i32, c_hi: u64,c_lo: u64)  -> BID_UINT128 {
    if lt128(54210108624275u64,4089650035136921599u64, c_hi >> 18,(c_lo >> 18) + (c_hi << 46)) {
        return_bid128(s,0x1F << 9,0u64,0u64)
    } else {
        return_bid128(s,0x1F << 9,c_hi >> 18,(c_lo >> 18) + (c_hi << 46))
    }
}

const BID_ROUNDBOUND_128: [BID_UINT128; 20] = [
    BID_UINT128 { w: [0u64 , 1u64 << 63] },         // BID_ROUNDING_TO_NEAREST | positive | even
    BID_UINT128 { w: [!0u64, (1u64 << 63) - 1] },   // BID_ROUNDING_TO_NEAREST | positive | odd
    BID_UINT128 { w: [0u64 , 1u64 << 63] },         // BID_ROUNDING_TO_NEAREST | negative | even
    BID_UINT128 { w: [!0u64, (1u64 << 63) - 1] },   // BID_ROUNDING_TO_NEAREST | negative | odd

    BID_UINT128 { w: [!0u64, !0u64] },   // BID_ROUNDING_DOWN       | positive | even
    BID_UINT128 { w: [!0u64, !0u64] },   // BID_ROUNDING_DOWN       | positive | odd
    BID_UINT128 { w: [0u64 ,  0u64] },   // BID_ROUNDING_DOWN       | negative | even
    BID_UINT128 { w: [0u64 ,  0u64] },   // BID_ROUNDING_DOWN       | negative | odd

    BID_UINT128 { w: [0u64 ,  0u64] },   // BID_ROUNDING_UP         | positive | even
    BID_UINT128 { w: [0u64 ,  0u64] },   // BID_ROUNDING_UP         | positive | odd
    BID_UINT128 { w: [!0u64, !0u64] },   // BID_ROUNDING_UP         | negative | even
    BID_UINT128 { w: [!0u64, !0u64] },   // BID_ROUNDING_UP         | negative | odd

    BID_UINT128 { w: [!0u64, !0u64] },   // BID_ROUNDING_TO_ZERO    | positive | even
    BID_UINT128 { w: [!0u64, !0u64] },   // BID_ROUNDING_TO_ZERO    | positive | odd
    BID_UINT128 { w: [!0u64, !0u64] },   // BID_ROUNDING_TO_ZERO    | negative | even
    BID_UINT128 { w: [!0u64, !0u64] },   // BID_ROUNDING_TO_ZERO    | negative | odd

    BID_UINT128 { w: [!0u64, (1u64 << 63) - 1] },   // BID_ROUNDING_TIES_AWAY  | positive | even
    BID_UINT128 { w: [!0u64, (1u64 << 63) - 1] },   // BID_ROUNDING_TIES_AWAY  | positive | odd
    BID_UINT128 { w: [!0u64, (1u64 << 63) - 1] },   // BID_ROUNDING_TIES_AWAY  | negative | even
    BID_UINT128 { w: [!0u64, (1u64 << 63) - 1] }    // BID_ROUNDING_TIES_AWAY  | negative | odd
];

// Table of powers of 5

const BID_POWER_FIVE: [BID_UINT128; 49] = [
    BID_UINT128 { w: [1u64, 0u64] },
    BID_UINT128 { w: [5u64, 0u64] },
    BID_UINT128 { w: [25u64, 0u64] },
    BID_UINT128 { w: [125u64, 0u64] },
    BID_UINT128 { w: [625u64, 0u64] },
    BID_UINT128 { w: [3125u64, 0u64] },
    BID_UINT128 { w: [15625u64, 0u64] },
    BID_UINT128 { w: [78125u64, 0u64] },
    BID_UINT128 { w: [390625u64, 0u64] },
    BID_UINT128 { w: [1953125u64, 0u64] },
    BID_UINT128 { w: [9765625u64, 0u64] },
    BID_UINT128 { w: [48828125u64, 0u64] },
    BID_UINT128 { w: [244140625u64, 0u64] },
    BID_UINT128 { w: [1220703125u64, 0u64] },
    BID_UINT128 { w: [6103515625u64, 0u64] },
    BID_UINT128 { w: [30517578125u64, 0u64] },
    BID_UINT128 { w: [152587890625u64, 0u64] },
    BID_UINT128 { w: [762939453125u64, 0u64] },
    BID_UINT128 { w: [3814697265625u64, 0u64] },
    BID_UINT128 { w: [19073486328125u64, 0u64] },
    BID_UINT128 { w: [95367431640625u64, 0u64] },
    BID_UINT128 { w: [476837158203125u64, 0u64] },
    BID_UINT128 { w: [2384185791015625u64, 0u64] },
    BID_UINT128 { w: [11920928955078125u64, 0u64] },
    BID_UINT128 { w: [59604644775390625u64, 0u64] },
    BID_UINT128 { w: [298023223876953125u64, 0u64] },
    BID_UINT128 { w: [1490116119384765625u64, 0u64] },
    BID_UINT128 { w: [7450580596923828125u64, 0u64] },
    BID_UINT128 { w: [359414837200037393u64, 2u64] },
    BID_UINT128 { w: [1797074186000186965u64, 10u64] },
    BID_UINT128 { w: [8985370930000934825u64, 50u64] },
    BID_UINT128 { w: [8033366502585570893u64, 252u64] },
    BID_UINT128 { w: [3273344365508751233u64, 1262u64] },
    BID_UINT128 { w: [16366721827543756165u64, 6310u64] },
    BID_UINT128 { w: [8046632842880574361u64, 31554u64] },
    BID_UINT128 { w: [3339676066983768573u64, 157772u64] },
    BID_UINT128 { w: [16698380334918842865u64, 788860u64] },
    BID_UINT128 { w: [9704925379756007861u64, 3944304u64] },
    BID_UINT128 { w: [11631138751360936073u64, 19721522u64] },
    BID_UINT128 { w: [2815461535676025517u64, 98607613u64] },
    BID_UINT128 { w: [14077307678380127585u64, 493038065u64] },
    BID_UINT128 { w: [15046306170771983077u64, 2465190328u64] },
    BID_UINT128 { w: [1444554559021708921u64, 12325951644u64] },
    BID_UINT128 { w: [7222772795108544605u64, 61629758220u64] },
    BID_UINT128 { w: [17667119901833171409u64, 308148791101u64] },
    BID_UINT128 { w: [14548623214327650581u64, 1540743955509u64] },
    BID_UINT128 { w: [17402883850509598057u64, 7703719777548u64] },
    BID_UINT128 { w: [13227442957709783821u64, 38518598887744u64] },
    BID_UINT128 { w: [10796982567420264257u64, 192592994438723u64] }
];


const BID_COEFFLIMITS_BID128: [BID_UINT128; 49] = [
    BID_UINT128 { w: [4003012203950112768u64, 542101086242752u64] },
    BID_UINT128 { w: [8179300070273843200u64, 108420217248550u64] },
    BID_UINT128 { w: [1635860014054768640u64, 21684043449710u64] },
    BID_UINT128 { w: [327172002810953728u64, 4336808689942u64] },
    BID_UINT128 { w: [7444132030046011392u64, 867361737988u64] },
    BID_UINT128 { w: [12556872850234933248u64, 173472347597u64] },
    BID_UINT128 { w: [9890072199530807296u64, 34694469519u64] },
    BID_UINT128 { w: [16735409698873802752u64, 6938893903u64] },
    BID_UINT128 { w: [14415128384000491520u64, 1387778780u64] },
    BID_UINT128 { w: [2883025676800098304u64, 277555756u64] },
    BID_UINT128 { w: [4265953950101929984u64, 55511151u64] },
    BID_UINT128 { w: [4542539604762296320u64, 11102230u64] },
    BID_UINT128 { w: [908507920952459264u64, 2220446u64] },
    BID_UINT128 { w: [3871050398932402176u64, 444089u64] },
    BID_UINT128 { w: [15531605338754121728u64, 88817u64] },
    BID_UINT128 { w: [10485018697234644992u64, 17763u64] },
    BID_UINT128 { w: [13165050183672659968u64, 3552u64] },
    BID_UINT128 { w: [10011707666218352640u64, 710u64] },
    BID_UINT128 { w: [2002341533243670528u64, 142u64] },
    BID_UINT128 { w: [7779165936132554752u64, 28u64] },
    BID_UINT128 { w: [12623879631452241920u64, 5u64] },
    BID_UINT128 { w: [2524775926290448384u64, 1u64] },
    BID_UINT128 { w: [4194304000000000000u64, 0u64] },
    BID_UINT128 { w: [838860800000000000u64, 0u64] },
    BID_UINT128 { w: [167772160000000000u64, 0u64] },
    BID_UINT128 { w: [33554432000000000u64, 0u64] },
    BID_UINT128 { w: [6710886400000000u64, 0u64] },
    BID_UINT128 { w: [1342177280000000u64, 0u64] },
    BID_UINT128 { w: [268435456000000u64, 0u64] },
    BID_UINT128 { w: [53687091200000u64, 0u64] },
    BID_UINT128 { w: [10737418240000u64, 0u64] },
    BID_UINT128 { w: [2147483648000u64, 0u64] },
    BID_UINT128 { w: [429496729600u64, 0u64] },
    BID_UINT128 { w: [85899345920u64, 0u64] },
    BID_UINT128 { w: [17179869184u64, 0u64] },
    BID_UINT128 { w: [3435973836u64, 0u64] },
    BID_UINT128 { w: [687194767u64, 0u64] },
    BID_UINT128 { w: [137438953u64, 0u64] },
    BID_UINT128 { w: [27487790u64, 0u64] },
    BID_UINT128 { w: [5497558u64, 0u64] },
    BID_UINT128 { w: [1099511u64, 0u64] },
    BID_UINT128 { w: [219902u64, 0u64] },
    BID_UINT128 { w: [43980u64, 0u64] },
    BID_UINT128 { w: [8796u64, 0u64] },
    BID_UINT128 { w: [1759u64, 0u64] },
    BID_UINT128 { w: [351u64, 0u64] },
    BID_UINT128 { w: [70u64, 0u64] },
    BID_UINT128 { w: [14u64, 0u64] },
    BID_UINT128 { w: [2u64, 0u64] }
];

// These are the different, bipartite, tables for conversion to bid128
// Using the same approach, the tables become extremely large
// And things are more amenable here since there's never overflow/underflow

const BID_OUTERTABLE_SIG: [BID_UINT256; 80] = [
    BID_UINT256 { w: [16710528681477587410u64, 1427578414467097172u64,      17470362193306814444u64, 17633471421292828081u64] },
    BID_UINT256 { w: [15880413049339289368u64, 3169162604521042544u64,  12421848348224877000u64, 10175591536883283100u64] },
    BID_UINT256 { w: [728324709502741634u64, 5487234822932806241u64,  14277366029702694882u64, 11743877385420605756u64] },
    BID_UINT256 { w: [5270439690693945016u64, 5335305964155802506u64,  4731239033579481048u64, 13553871098685738146u64] },
    BID_UINT256 { w: [15770926697301461842u64, 17478494563481727979u64,  12172666691698088779u64, 15642825255298684824u64] },
    BID_UINT256 { w: [6706015564063194464u64, 9524484409513358023u64,  3584925281718916951u64, 18053733887991431306u64] },
    BID_UINT256 { w: [11970480524618434228u64, 11405570099769256704u64,  15462553542164535233u64, 10418108684938663938u64] },
    BID_UINT256 { w: [6786207772287397676u64, 2319456072422691258u64,  3306628541457879036u64, 12023771840725819358u64] },
    BID_UINT256 { w: [11981052113010165492u64, 3504057943690712651u64,  1876153621163772099u64, 13876903538819465956u64] },
    BID_UINT256 { w: [9393164661428669080u64, 12786250932199773041u64,  1469280998340568779u64, 16015644206874417279u64] },
    BID_UINT256 { w: [16924685242153318850u64, 18017830257179898541u64,  8443357802200517361u64, 9242006282008467740u64] },
    BID_UINT256 { w: [10964968671057563176u64, 5039440430669711539u64,  5426243050445487622u64, 10666405798403203685u64] },
    BID_UINT256 { w: [10955754838860298353u64, 7697974614691938479u64,  5802604364043796934u64, 12310337083160321132u64] },
    BID_UINT256 { w: [2020816881108765590u64, 11827301330378587775u64,  11428107909474365520u64, 14207634883319258514u64] },
    BID_UINT256 { w: [17088069107880998350u64, 4283872614129133981u64,  3596834484036483711u64, 16397348635874181367u64] },
    BID_UINT256 { w: [17878879927905357932u64, 16765016545576715295u64,  16689816215723394984u64, 9462273083962776199u64] },
    BID_UINT256 { w: [13121733289080687293u64, 18283685101712419716u64,  16276586284347626380u64, 10920620632484725600u64] },
    BID_UINT256 { w: [17814811358648632259u64, 13245640156276305425u64,  16363965810173909683u64, 12603732099085151178u64] },
    BID_UINT256 { w: [4756697993914874888u64, 11508234184157253656u64,  5137266535116401279u64, 14546248621894116172u64] },
    BID_UINT256 { w: [5318236458935323174u64, 6543830884414701181u64,  6453355338781772809u64, 16788150311867950084u64] },
    BID_UINT256 { w: [6485710970464102310u64, 9658720758000782538u64,  1405691438411884535u64, 9687789553853107178u64] },
    BID_UINT256 { w: [16668567668910748869u64, 7353216905500064137u64,  16398637311140236340u64, 11180894225541718927u64] },
    BID_UINT256 { w: [10250898639443956700u64, 17209112682100433509u64,  10404161081088486903u64, 12904119664018836844u64] },
    BID_UINT256 { w: [8190593687966138954u64, 9395575747272723417u64,  5270639644724875979u64, 14892932617404296676u64] },
    BID_UINT256 { w: [16096765186944088526u64, 5812137315202163815u64,  13827109944906121794u64, 17188266051577202911u64] },
    BID_UINT256 { w: [13125058493821651226u64, 13878096157524874998u64,  7819283672493662452u64, 9918680808189048078u64] },
    BID_UINT256 { w: [10784977039313888136u64, 7095114120404217728u64,  5980679097159643429u64, 11447370977331402726u64] },
    BID_UINT256 { w: [18074025829186132275u64, 1141984379626550674u64,  7557580538320593620u64, 13211666432945230258u64] },
    BID_UINT256 { w: [884127375074722974u64, 5630658839879210216u64, 8888788495242174599u64,  15247879210087606793u64] },
    BID_UINT256 { w: [14794677677148287412u64, 15991859528909753139u64,  2255166953101703543u64, 17597917839164816062u64] },
    BID_UINT256 { w: [11781503818372409883u64, 16487377189598053250u64,  1614766483381505408u64, 10155074945409931597u64] },
    BID_UINT256 { w: [13901203812957478350u64, 17671725616207330354u64,  9774501520532043416u64, 11720198729122693309u64] },
    BID_UINT256 { w: [2841277750318224700u64, 62614824260888948u64, 7875289095414864909u64,  13526543032773672749u64] },
    BID_UINT256 { w: [4177215723684349918u64, 5549883551398310595u64,  6548711429670794128u64, 15611285324269742443u64] },
    BID_UINT256 { w: [10113135653152274419u64, 1238174514434849746u64,  15010187426055142985u64, 18017332949391848572u64] },
    BID_UINT256 { w: [15332868447221136909u64, 16659234357027498643u64,  8156814090647504084u64, 10397103116953834012u64] },
    BID_UINT256 { w: [15245187402216469644u64, 12129929088655149192u64,  9861651730211963150u64, 11999528845718521943u64] },
    BID_UINT256 { w: [11169863271521019024u64, 11690833164181629132u64,  18055231442152805128u64, 13848924157002783033u64] },
    BID_UINT256 { w: [5681139181384005971u64, 16315598095635316730u64,  12429006944274865118u64, 15983352577617880224u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 9223372036854775808u64] },
    BID_UINT256 { w: [847738094735128551u64, 159020156881263929u64, 14298703881791668535u64, 10644899600020376799u64] },
    BID_UINT256 { w: [12571812103339493257u64, 9592188640606484874u64,  15977522551232326327u64, 12285516299433008781u64] },
    BID_UINT256 { w: [11255846670375652269u64, 16219642565822741785u64,  1164180458167399492u64, 14178988662640388631u64] },
    BID_UINT256 { w: [4768530159026621925u64, 11269558331910606010u64,  14728279675391465720u64, 16364287392998134214u64] },
    BID_UINT256 { w: [10435171899994305314u64, 3358688235984080491u64,  10873005112892106269u64, 9443194724678278428u64] },
    BID_UINT256 { w: [9001934648837042518u64, 12742858465034581069u64,  7821978264675184102u64, 10898601872067700364u64] },
    BID_UINT256 { w: [17621267265258286727u64, 4697230115438671198u64,  9730745556445007669u64, 12578319756070083561u64] },
    BID_UINT256 { w: [15489206033570711069u64, 5939008219696634639u64,  7281543418588385486u64, 14516919669433371671u64] },
    BID_UINT256 { w: [5582382164278045428u64, 1021128504191590019u64,  15859662269683349667u64, 16754301112998936544u64] },
    BID_UINT256 { w: [13306060077138970688u64, 17077419079040409017u64,  602300193611639289u64, 9668256495766433483u64] },
    BID_UINT256 { w: [16144900726383728979u64, 6332437060439625781u64,  3394061071468721991u64, 11158350687084940805u64] },
    BID_UINT256 { w: [841527738022137013u64, 8576187517129556015u64, 4780478900157118356u64,  12878101662951253988u64] },
    BID_UINT256 { w: [6209518431268106959u64, 6563228687006195825u64,  8680557599339190037u64, 14862904661462481806u64] },
    BID_UINT256 { w: [13777918056850427098u64, 13980713634323581067u64,  3260730320187665275u64, 17153610117183879308u64] },
    BID_UINT256 { w: [14026398967643035423u64, 16044002814696042637u64,  13563648246219923183u64, 9898682214361989196u64] },
    BID_UINT256 { w: [8580849201736980837u64, 7652064075251385167u64,  12055336643618066002u64, 11424290153682525668u64] },
    BID_UINT256 { w: [7703450277136593061u64, 30939122015382097u64, 1733744904199768989u64,  13185028339041359606u64] },
    BID_UINT256 { w: [16645858086931268484u64, 268706294728574543u64,  4562366333509913804u64, 15217135591158481007u64] },
    BID_UINT256 { w: [1535817262145462730u64, 16249574698204674087u64,  1726174694286833848u64, 17562435942139069664u64] },
    BID_UINT256 { w: [1327779613951528273u64, 12607890553358950732u64,  6773080245737622022u64, 10134599720625107110u64] },
    BID_UINT256 { w: [10146669700226523625u64, 6816618733538609533u64,  17338427607494047961u64, 11696567815043613180u64] },
    BID_UINT256 { w: [1218646606393179524u64, 8053984438814192242u64,  5512554737593155320u64, 13499270067222312908u64] },
    BID_UINT256 { w: [8529816360522570005u64, 2898610325645650649u64,  12799329154556421864u64, 15579808985797328396u64] },
    BID_UINT256 { w: [8976626101186384018u64, 17306366585957786234u64,  18289272351796647404u64, 17981005404381600394u64] },
    BID_UINT256 { w: [13259258789938866699u64, 3853966764738768487u64,  3962898110873089456u64, 10376139901559067117u64] },
    BID_UINT256 { w: [899097863387258947u64, 18205835716688941338u64,  5828614502416977816u64, 11975334730781032005u64] },
    BID_UINT256 { w: [6805696657844643720u64, 11269663690239600300u64,  15713752492130876427u64, 13821001188766021149u64] },
    BID_UINT256 { w: [1390669429605106863u64, 9874674503958832077u64,  10784451562526769943u64, 15951126056533488631u64] },
    BID_UINT256 { w: [5704986635434998471u64, 13359511205918707297u64,  13484363347568202582u64, 18409550726197325520u64] },
    BID_UINT256 { w: [8031416311578790746u64, 15203770801091158414u64,  10108131133879485063u64, 10623436763626360685u64] },
    BID_UINT256 { w: [14540970352057967818u64, 10823414366732926995u64,  16152175176069010361u64, 12260745560745135745u64] },
    BID_UINT256 { w: [15950896424073439808u64, 7311065895593189991u64,  14504991862333000338u64, 14150400200058902426u64] },
    BID_UINT256 { w: [5978819348613013533u64, 5596367464999577452u64,  9804643584580705193u64, 16331292810031855499u64] },
    BID_UINT256 { w: [8586457898440847299u64, 6018330550275346810u64,  7956755163056284140u64, 9424154832238877876u64] },
    BID_UINT256 { w: [1114429888821394320u64, 1760611426277998851u64,  9839409379426382903u64, 10876627507095459665u64] },
    BID_UINT256 { w: [7554605751361075608u64, 6504275622057553570u64,  9148491728899045148u64, 12552958650829068784u64] },
    BID_UINT256 { w: [9208049516541304162u64, 15518058123431536615u64,  17563500997894963674u64, 14487649851631658771u64] },
    BID_UINT256 { w: [1484107481346855224u64, 16657394431011607502u64,  12009304572091620947u64, 16720520162760224108u64] },
    BID_UINT256 { w: [14325586681310127114u64, 11250726580617083666u64,  2403442209646777766u64, 9648762821313776241u64] },
    BID_UINT256 { w: [14963893077912294692u64, 3450059817568720983u64,  15313875826588494017u64, 11135852602159508258u64] }
];

const BID_INNERTABLE_SIG: [BID_UINT256; 128] = [
    BID_UINT256 { w: [1014026100135492416u64, 3035406636157676337u64,      4549648098962661924u64, 12141680576410806693u64] },
    BID_UINT256 { w: [5879218643596753424u64, 3794258295197095421u64,  10298746142130715309u64, 15177100720513508366u64] },
    BID_UINT256 { w: [5980354661461664842u64, 4677254443711878590u64,  1825030320404309164u64, 9485687950320942729u64] },
    BID_UINT256 { w: [16698815363681856860u64, 5846568054639848237u64,  6892973918932774359u64, 11857109937901178411u64] },
    BID_UINT256 { w: [7038461149320157363u64, 2696524049872422393u64,  4004531380238580045u64, 14821387422376473014u64] },
    BID_UINT256 { w: [15928253264393568112u64, 3991170540383957947u64,  16337890167931276240u64, 9263367138985295633u64] },
    BID_UINT256 { w: [15298630562064572236u64, 4988963175479947434u64,  6587304654631931588u64, 11579208923731619542u64] },
    BID_UINT256 { w: [9899916165725939487u64, 6236203969349934293u64,  17457502855144690293u64, 14474011154664524427u64] },
    BID_UINT256 { w: [16986581225584812263u64, 12406940980114805770u64,  17210192550503474962u64, 18092513943330655534u64] },
    BID_UINT256 { w: [15228299284417895569u64, 12366024130999141510u64,  6144684325637283947u64, 11307821214581659709u64] },
    BID_UINT256 { w: [9812002068667593653u64, 10845844145321538984u64,  12292541425473992838u64, 14134776518227074636u64] },
    BID_UINT256 { w: [12265002585834492066u64, 4333933144797147922u64,  15365676781842491048u64, 17668470647783843295u64] },
    BID_UINT256 { w: [12277312634573945445u64, 2708708215498217451u64,  16521077016292638761u64, 11042794154864902059u64] },
    BID_UINT256 { w: [10734954774790043902u64, 7997571287800159718u64,  16039660251938410547u64, 13803492693581127574u64] },
    BID_UINT256 { w: [4195321431632779070u64, 5385278091322811744u64,  10826203278068237376u64, 17254365866976409468u64] },
    BID_UINT256 { w: [2622075894770486919u64, 3365798807076757340u64,  15989749085647424168u64, 10783978666860255917u64] },
    BID_UINT256 { w: [3277594868463108648u64, 4207248508845946675u64,  6152128301777116498u64, 13479973333575319897u64] },
    BID_UINT256 { w: [17932051640861049522u64, 14482432672912209151u64,  12301846395648783526u64, 16849966666969149871u64] },
    BID_UINT256 { w: [18125061303179237808u64, 4439834402142742815u64,  14606183024921571560u64, 10531229166855718669u64] },
    BID_UINT256 { w: [18044640610546659355u64, 5549793002678428519u64,  4422670725869800738u64, 13164036458569648337u64] },
    BID_UINT256 { w: [17944114744755936290u64, 16160613290202811457u64,  10140024425764638826u64, 16455045573212060421u64] },
    BID_UINT256 { w: [4297542687831378326u64, 14712069324804145065u64,  8643358275316593218u64, 10284403483257537763u64] },
    BID_UINT256 { w: [9983614378216610811u64, 9166714619150405523u64,  6192511825718353619u64, 12855504354071922204u64] },
    BID_UINT256 { w: [7867831954343375609u64, 6846707255510619000u64,  7740639782147942024u64, 16069380442589902755u64] },
    BID_UINT256 { w: [4917394971464609756u64, 4279192034694136875u64,  2532056854628769813u64, 10043362776618689222u64] },
    BID_UINT256 { w: [1535057695903374291u64, 9960676061795058998u64,  12388443105140738074u64, 12554203470773361527u64] },
    BID_UINT256 { w: [11142194156733993672u64, 3227473040389047939u64,  10873867862998534689u64, 15692754338466701909u64] },
    BID_UINT256 { w: [4658028338745052093u64, 13546385696311624722u64,  9102010423587778132u64, 9807971461541688693u64] },
    BID_UINT256 { w: [15045907460286090924u64, 16932982120389530902u64,  15989199047912110569u64, 12259964326927110866u64] },
    BID_UINT256 { w: [9584012288502837847u64, 7331169595204749916u64,  10763126773035362404u64, 15324955408658888583u64] },
    BID_UINT256 { w: [15213379717169049462u64, 13805353033857744505u64,  13644483260788183358u64, 9578097130411805364u64] },
    BID_UINT256 { w: [5181666591179148116u64, 8033319255467404824u64,  17055604075985229198u64, 11972621413014756705u64] },
    BID_UINT256 { w: [6477083238973935145u64, 818277032479480222u64, 7484447039699372786u64,  14965776766268445882u64] },
    BID_UINT256 { w: [17883235079640873178u64, 5123109163727063042u64,  9289465418239495895u64, 9353610478917778676u64] },
    BID_UINT256 { w: [13130671812696315664u64, 1792200436231440899u64,  11611831772799369869u64, 11692013098647223345u64] },
    BID_UINT256 { w: [11801653747443006676u64, 6851936563716689028u64,  679731660717048624u64, 14615016373309029182u64] },
    BID_UINT256 { w: [14752067184303758345u64, 8564920704645861285u64,  10073036612751086588u64, 18268770466636286477u64] },
    BID_UINT256 { w: [11525884999403542918u64, 14576447477258439111u64,  8601490892183123069u64, 11417981541647679048u64] },
    BID_UINT256 { w: [9795670230827040743u64, 4385501291290885177u64,  10751863615228903837u64, 14272476927059598810u64] },
    BID_UINT256 { w: [16856273806961188833u64, 10093562632540994375u64,  4216457482181353988u64, 17840596158824498513u64] },
    BID_UINT256 { w: [17452700156991824877u64, 15531848682192897292u64,  14164500972431816002u64, 11150372599265311570u64] },
    BID_UINT256 { w: [3369131122530229480u64, 10191438815886345808u64,  8482254178684994195u64, 13937965749081639463u64] },
    BID_UINT256 { w: [4211413903162786849u64, 8127612501430544356u64,  5991131704928854840u64, 17422457186352049329u64] },
    BID_UINT256 { w: [11855505726331517589u64, 5079757813394090222u64,  15273672361649004035u64, 10889035741470030830u64] },
    BID_UINT256 { w: [5596010121059621178u64, 1738011248315224874u64,  9868718415206479236u64, 13611294676837538538u64] },
    BID_UINT256 { w: [16218384688179302281u64, 2172514060394031092u64,  3112525982153323237u64, 17014118346046923173u64] },
    BID_UINT256 { w: [913118393257288118u64, 3663664296959963385u64, 4251171748059520975u64,  10633823966279326983u64] },
    BID_UINT256 { w: [5753084009998998051u64, 18414638426482117943u64,  702278666647013314u64, 13292279957849158729u64] },
    BID_UINT256 { w: [2579668994071359659u64, 13794925996247871621u64,  5489534351736154547u64, 16615349947311448411u64] },
    BID_UINT256 { w: [3918136130508293739u64, 6315985738441225811u64,  1125115960621402640u64, 10384593717069655257u64] },
    BID_UINT256 { w: [285984144707979270u64, 7894982173051532264u64, 6018080969204141204u64,  12980742146337069071u64] },
    BID_UINT256 { w: [357480180884974087u64, 9868727716314415330u64, 2910915193077788601u64,  16225927682921336339u64] },
    BID_UINT256 { w: [4835111131480496709u64, 17697169868764979341u64,  17960223060169475539u64, 10141204801825835211u64] },
    BID_UINT256 { w: [10655574932778008790u64, 17509776317528836272u64,  17838592806784456520u64, 12676506002282294014u64] },
    BID_UINT256 { w: [13319468665972510987u64, 3440476323201493724u64,  13074868971625794843u64, 15845632502852867518u64] },
    BID_UINT256 { w: [17548039953087595175u64, 18291198766496791241u64,  3560107088838733872u64, 9903520314283042199u64] },
    BID_UINT256 { w: [8099991886077330257u64, 4417254384411437436u64,  18285191916330581053u64, 12379400392853802748u64] },
    BID_UINT256 { w: [10124989857596662821u64, 10133253998941684699u64,  4409745821703674700u64, 15474250491067253436u64] },
    BID_UINT256 { w: [4022275651784220311u64, 15556655786193328745u64,  11979463175419572495u64, 9671406556917033397u64] },
    BID_UINT256 { w: [9639530583157663293u64, 14834133714314273027u64,  1139270913992301907u64, 12089258196146291747u64] },
    BID_UINT256 { w: [7437727210519691212u64, 13930981124465453380u64,  15259146697772541096u64, 15111572745182864683u64] },
    BID_UINT256 { w: [13871951543429582816u64, 8706863202790908362u64,  7231123676894144233u64, 9444732965739290427u64] },
    BID_UINT256 { w: [8116567392432202712u64, 15495265021916023357u64,  4427218577690292387u64, 11805916207174113034u64] },
    BID_UINT256 { w: [14757395258967641293u64, 14757395258967641292u64,  14757395258967641292u64, 14757395258967641292u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 9223372036854775808u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 11529215046068469760u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 14411518807585587200u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 18014398509481984000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 11258999068426240000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 14073748835532800000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 17592186044416000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 10995116277760000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 13743895347200000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 17179869184000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 10737418240000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 13421772800000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 16777216000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 10485760000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 13107200000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 16384000000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 10240000000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 12800000000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 16000000000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 10000000000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 12500000000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 15625000000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 9765625000000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 12207031250000000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 15258789062500000000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 9536743164062500000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 11920928955078125000u64] },
    BID_UINT256 { w: [0u64, 0u64, 0u64, 14901161193847656250u64] },
    BID_UINT256 { w: [0u64, 0u64, 4611686018427387904u64, 9313225746154785156u64] },
    BID_UINT256 { w: [0u64, 0u64, 5764607523034234880u64, 11641532182693481445u64] },
    BID_UINT256 { w: [0u64, 0u64, 11817445422220181504u64, 14551915228366851806u64] },
    BID_UINT256 { w: [0u64, 0u64, 5548434740920451072u64, 18189894035458564758u64] },
    BID_UINT256 { w: [0u64, 0u64, 17302829768357445632u64, 11368683772161602973u64] },
    BID_UINT256 { w: [0u64, 0u64, 7793479155164643328u64, 14210854715202003717u64] },
    BID_UINT256 { w: [0u64, 0u64, 14353534962383192064u64, 17763568394002504646u64] },
    BID_UINT256 { w: [0u64, 0u64, 4359273333062107136u64, 11102230246251565404u64] },
    BID_UINT256 { w: [0u64, 0u64, 5449091666327633920u64, 13877787807814456755u64] },
    BID_UINT256 { w: [0u64, 0u64, 2199678564482154496u64, 17347234759768070944u64] },
    BID_UINT256 { w: [0u64, 0u64, 1374799102801346560u64, 10842021724855044340u64] },
    BID_UINT256 { w: [0u64, 0u64, 1718498878501683200u64, 13552527156068805425u64] },
    BID_UINT256 { w: [0u64, 0u64, 6759809616554491904u64, 16940658945086006781u64] },
    BID_UINT256 { w: [0u64, 0u64, 6530724019560251392u64, 10587911840678754238u64] },
    BID_UINT256 { w: [0u64, 0u64, 17386777061305090048u64, 13234889800848442797u64] },
    BID_UINT256 { w: [0u64, 0u64, 7898413271349198848u64, 16543612251060553497u64] },
    BID_UINT256 { w: [0u64, 0u64, 16465723340661719040u64, 10339757656912845935u64] },
    BID_UINT256 { w: [0u64, 0u64, 15970468157399760896u64, 12924697071141057419u64] },
    BID_UINT256 { w: [0u64, 0u64, 15351399178322313216u64, 16155871338926321774u64] },
    BID_UINT256 { w: [0u64, 0u64, 4982938468024057856u64, 10097419586828951109u64] },
    BID_UINT256 { w: [0u64, 0u64, 10840359103457460224u64, 12621774483536188886u64] },
    BID_UINT256 { w: [0u64, 0u64, 4327076842467049472u64, 15777218104420236108u64] },
    BID_UINT256 { w: [0u64, 0u64, 11927795063396681728u64, 9860761315262647567u64] },
    BID_UINT256 { w: [0u64, 0u64, 10298057810818464256u64, 12325951644078309459u64] },
    BID_UINT256 { w: [0u64, 0u64, 8260886245095692416u64, 15407439555097886824u64] },
    BID_UINT256 { w: [0u64, 0u64, 5163053903184807760u64, 9629649721936179265u64] },
    BID_UINT256 { w: [0u64, 0u64, 11065503397408397604u64, 12037062152420224081u64] },
    BID_UINT256 { w: [0u64, 0u64, 18443565265187884909u64, 15046327690525280101u64] },
    BID_UINT256 { w: [0u64, 2305843009213693952u64, 13833071299956122020u64,  9403954806578300063u64] },
    BID_UINT256 { w: [0u64, 2882303761517117440u64, 12679653106517764621u64,  11754943508222875079u64] },
    BID_UINT256 { w: [0u64, 8214565720323784704u64, 11237880364719817872u64,  14693679385278593849u64] },
    BID_UINT256 { w: [0u64, 10268207150404730880u64, 212292400617608628u64,  18367099231598242312u64] },
    BID_UINT256 { w: [0u64, 15641001505857732608u64, 132682750386005392u64,  11479437019748901445u64] },
    BID_UINT256 { w: [0u64, 1104507808612614144u64, 4777539456409894645u64,  14349296274686126806u64] },
    BID_UINT256 { w: [0u64, 5992320779193155584u64, 15195296357367144114u64,  17936620343357658507u64] },
    BID_UINT256 { w: [0u64, 8356886505423110144u64, 7191217214140771119u64,  11210387714598536567u64] }
];

const BID_OUTERTABLE_EXP: [i32; 80] = [
  -16839,
  -16413,
  -15988,
  -15563,
  -15138,
  -14713,
  -14287,
  -13862,
  -13437,
  -13012,
  -12586,
  -12161,
  -11736,
  -11311,
  -10886,
  -10460,
  -10035,
  -9610,
  -9185,
  -8760,
  -8334,
  -7909,
  -7484,
  -7059,
  -6634,
  -6208,
  -5783,
  -5358,
  -4933,
  -4508,
  -4082,
  -3657,
  -3232,
  -2807,
  -2382,
  -1956,
  -1531,
  -1106,
  -681,
  -255,
  170,
  595,
  1020,
  1445,
  1871,
  2296,
  2721,
  3146,
  3571,
  3997,
  4422,
  4847,
  5272,
  5697,
  6123,
  6548,
  6973,
  7398,
  7823,
  8249,
  8674,
  9099,
  9524,
  9949,
  10375,
  10800,
  11225,
  11650,
  12075,
  12501,
  12926,
  13351,
  13776,
  14202,
  14627,
  15052,
  15477,
  15902,
  16328,
  16753,
];

const BID_INNERTABLE_EXP: [i32; 128] = [
  -468,
  -465,
  -461,
  -458,
  -455,
  -451,
  -448,
  -445,
  -442,
  -438,
  -435,
  -432,
  -428,
  -425,
  -422,
  -418,
  -415,
  -412,
  -408,
  -405,
  -402,
  -398,
  -395,
  -392,
  -388,
  -385,
  -382,
  -378,
  -375,
  -372,
  -368,
  -365,
  -362,
  -358,
  -355,
  -352,
  -349,
  -345,
  -342,
  -339,
  -335,
  -332,
  -329,
  -325,
  -322,
  -319,
  -315,
  -312,
  -309,
  -305,
  -302,
  -299,
  -295,
  -292,
  -289,
  -285,
  -282,
  -279,
  -275,
  -272,
  -269,
  -265,
  -262,
  -259,
  -255,
  -252,
  -249,
  -246,
  -242,
  -239,
  -236,
  -232,
  -229,
  -226,
  -222,
  -219,
  -216,
  -212,
  -209,
  -206,
  -202,
  -199,
  -196,
  -192,
  -189,
  -186,
  -182,
  -179,
  -176,
  -172,
  -169,
  -166,
  -162,
  -159,
  -156,
  -153,
  -149,
  -146,
  -143,
  -139,
  -136,
  -133,
  -129,
  -126,
  -123,
  -119,
  -116,
  -113,
  -109,
  -106,
  -103,
  -99,
  -96,
  -93,
  -89,
  -86,
  -83,
  -79,
  -76,
  -73,
  -69,
  -66,
  -63,
  -60,
  -56,
  -53,
  -50,
  -46,
];

// **********************************************************************

pub (crate) fn binary32_to_bid128(x: f32, rnd_mode: RoundingMode, pfpsf: &mut _IDEC_flags) -> BID_UINT128 {
    let mut c: BID_UINT128 = Default::default();
    let mut c_prov_hi: BID_UINT64;
    let mut c_prov_lo: BID_UINT64;
    let mut r: BID_UINT256;
    let mut z: BID_UINT512;

    let mut e: i32 = 0;
    let mut s: i32 = 0;
    let mut t: i32 = 0;
    let mut e_out: i32;
    let e_plus: i32;
    let mut e_hi: i32;
    let e_lo: i32;
    let mut f: i32;

    // Unpack the input

    let res: Option<BID_UINT128> = unpack_binary32(
        x,
        &mut s,
        &mut e,
        &mut c.w[1],
        &mut t,
        &return_bid128_zero,
        &return_bid128_inf,
        &return_bid128_nan,
        pfpsf);

    if res.is_some() {
        return res.unwrap();
    }

    // Now -172<=e<=104 (104 for max normal, -149 for min normal, -172 for min denormal)

    // Shift up to the top: like a pure quad coefficient with a shift of 15.
    // In our case, this is 2^{113-24+15} times the core, so unpack at the
    // high end shifted by 40.

    c.w[0]   = 0;
    c.w[1] <<= 40;

    t += 113 - 24;
    e -= 113 - 24; // Now e belongs [-238..15]

    // (We never need to check for overflow: this format is the biggest of all!)

    // Now filter out all the exact cases where we need to specially force
    // the exponent to 0. We can let through inexact cases and those where the
    // main path will do the right thing anyway, e.g. integers outside coeff range.
    //
    // First check that e <= 0, because if e > 0, the input must be >= 2^113,
    // which is too large for the coefficient of any target decimal format.
    // We write a = -(e + t)
    //
    // (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially
    //     iff it fits in the coefficient range. Shift c' = c >> -e, and
    //     compare with the coefficient range; if it's in range then c' is
    //     our coefficient, exponent is 0. Otherwise we pass through.
    //
    // (2) If a > 0 then we have a non-integer input. The special case would
    //     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now
    //     if a > 48 we can immediately forget this, since 5^49 > 10^34.
    //     Otherwise we determine whether we're in range by a table based on
    //     a, and if so get the multiplier also from a table based on a.
    //
    // Note that when we shift, we need to take into account the fact that
    // c is already 15 places to the left in preparation for the reciprocal
    // multiplication; thus we add 15 to all the shift counts

    if e <= 0 {
        let mut cint: BID_UINT128 = Default::default();
        let a: i32 = -(e + t);
        cint.w[1] = c.w[1];
        cint.w[1] = c.w[1];
        cint.w[0] = c.w[0];
        if a <= 0 {
            (cint.w[1], cint.w[0]) = srl128(cint.w[1], cint.w[0], (15 - e) as u64);
            if lt128(cint.w[1], cint.w[0], 542101086242752u64, 4003012203950112768u64) {
                return return_bid128(s, 6176, cint.w[1], cint.w[0]);
            }
        } else if a <= 48 {
            let mut pow5: &BID_UINT128 = &BID_COEFFLIMITS_BID128[a as usize];
            (cint.w[1], cint.w[0]) = srl128(cint.w[1], cint.w[0], (15 + t) as u64);
            if le128(cint.w[1], cint.w[0], pow5.w[1], pow5.w[0]) {
                let mut cc: BID_UINT128 = Default::default();
                cc.w[1] = cint.w[1];
                cc.w[0] = cint.w[0];
                pow5    = &BID_POWER_FIVE[a as usize];
                cc      = __mul_128x128_low(&cc, pow5);
                return return_bid128(s, 6176 - a, cc.w[1], cc.w[0]);
            }
        }
    }
    // Input exponent can stretch between the maximal and minimal
    // exponents (remembering we force normalization): -16607 <= e <= 16271

    // Compute the estimated decimal exponent e_out; the provisional exponent
    // will be either "e_out" or "e_out-1" depending on later significand check
    // NB: this is the *biased* exponent

    e_plus = e + 42152;
    e_out  = (((19728 * e_plus) + ((19779 * e_plus) >> 16)) >> 16) - 6512;

    // Set up pointers into the bipartite table

    e_hi   = 11232 - e_out;
    e_lo   = e_hi & 127;
    e_hi >>= 7;

    // Look up the inner entry first

    r = BID_INNERTABLE_SIG[e_lo as usize];
    f = BID_INNERTABLE_EXP[e_lo as usize];

    // If we need the other entry, multiply significands and add exponents

    if e_hi != 39 {
        let s_prime: &BID_UINT256 = &BID_OUTERTABLE_SIG[e_hi as usize];
        let t_prime: BID_UINT512;
        f       = f + 256 + BID_OUTERTABLE_EXP[e_hi as usize];
        t_prime = __mul_256x256_to_512(&r, s_prime);
        r.w[0]  = t_prime.w[4] + 1;
        r.w[1]  = t_prime.w[5];
        r.w[2]  = t_prime.w[6];
        r.w[3]  = t_prime.w[7];
    }

    z = __mul_128x256_to_384(&c, &r);

    // Make adjustive shift, ignoring the lower 128 bits

    e = -(241 + e + f);
    srl384_short(&mut z, e);

    // Now test against 10^33 and so decide on adjustment
    // I feel there ought to be a smarter way of doing the multiplication

    if lt128(z.w[5], z.w[4], 54210108624275u64, 4089650035136921600u64) {
        __mul_10x384_to_384(&mut z);
        e_out -= 1;
    }
    // Set up provisional results

      c_prov_hi = z.w[5];
      c_prov_lo = z.w[4];

    // Round using round-sticky words
    // If we spill over into the next decade, correct

    let rb = BID_ROUNDBOUND_128[(((rnd_mode as u64) << 2) + (((s as u64) & 1) << 1) + (c_prov_lo & 1)) as usize];

    if lt128(rb.w[1], rb.w[0], z.w[3], z.w[2]) {
        c_prov_lo += 1;
        if c_prov_lo == 0 {
            c_prov_hi += 1;
        } else if (c_prov_lo == 4003012203950112768u64) && (c_prov_hi == 542101086242752u64) {
            c_prov_hi = 54210108624275u64;
            c_prov_lo = 4089650035136921600u64;
            e_out    += 1;
        }
    }
    // Don't need to check overflow or underflow; however set inexact flag

    if (z.w[3] != 0) || (z.w[2] != 0) {
        __set_status_flags(pfpsf, StatusFlags::BID_INEXACT_EXCEPTION);
    }

    // Package up the result

    return_bid128(s, e_out, c_prov_hi, c_prov_lo)
}

// **********************************************************************

pub (crate) fn binary64_to_bid128(x: f64, rnd_mode: RoundingMode, pfpsf: &mut _IDEC_flags) -> BID_UINT128 {
    let mut c: BID_UINT128 = Default::default();
    let mut c_prov_hi: BID_UINT64;
    let mut c_prov_lo: BID_UINT64;
    let mut r: BID_UINT256;
    let mut z: BID_UINT512;

    let mut e: i32 = 0;
    let mut s: i32 = 0;
    let mut t: i32 = 0;
    let mut e_out: i32;
    let e_plus: i32;
    let mut e_hi: i32;
    let e_lo: i32;
    let mut f: i32;

    // Unpack the input

    let res = unpack_binary64(x, &mut s, &mut e, &mut c.w[1], &mut t, &return_bid128_zero, &return_bid128_inf, &return_bid128_nan, pfpsf);

    if res.is_some() {
        return res.unwrap();
    }

    // Now -1126<=e<=971 (971 for max normal, -1074 for min normal, -1126 for min denormal)

    // Shift up to the top: like a pure quad coefficient with a shift of 15.
    // In our case, this is 2^{113-53+15} times the core, so unpack at the
    // high end shifted by 11.

    c.w[0]   = 0;
    c.w[1] <<= 11;

    t += 113 - 53;
    e -= 113 - 53; // Now e belongs [-1186;911].

    // (We never need to check for overflow: this format is the biggest of all!)

    // Now filter out all the exact cases where we need to specially force
    // the exponent to 0. We can let through inexact cases and those where the
    // main path will do the right thing anyway, e.g. integers outside coeff range.
    //
    // First check that e <= 0, because if e > 0, the input must be >= 2^113,
    // which is too large for the coefficient of any target decimal format.
    // We write a = -(e + t)
    //
    // (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially
    //     iff it fits in the coefficient range. Shift c' = c >> -e, and
    //     compare with the coefficient range; if it's in range then c' is
    //     our coefficient, exponent is 0. Otherwise we pass through.
    //
    // (2) If a > 0 then we have a non-integer input. The special case would
    //     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now
    //     if a > 48 we can immediately forget this, since 5^49 > 10^34.
    //     Otherwise we determine whether we're in range by a table based on
    //     a, and if so get the multiplier also from a table based on a.
    //
    // Note that when we shift, we need to take into account the fact that
    // c is already 15 places to the left in preparation for the reciprocal
    // multiplication; thus we add 15 to all the shift counts

    if e <= 0 {
        let mut cint: BID_UINT128 = Default::default();
        let a: i32 = -(e + t);
        cint.w[1] = c.w[1];
        cint.w[0] = c.w[0];
        if a <= 0 {
            (cint.w[1], cint.w[0]) = srl128(cint.w[1], cint.w[0], (15 - e) as u64);
            if lt128(cint.w[1], cint.w[0], 542101086242752u64, 4003012203950112768u64) {
                return return_bid128(s, 6176, cint.w[1], cint.w[0]);
            }
        } else if a <= 48 {
            let mut pow5: &BID_UINT128 = &BID_COEFFLIMITS_BID128[a as usize];
            (cint.w[1], cint.w[0]) = srl128(cint.w[1], cint.w[0], (15 + t) as u64);
            if le128(cint.w[1], cint.w[0], pow5.w[1], pow5.w[0]) {
                let mut cc: BID_UINT128 = Default::default();
                cc.w[1] = cint.w[1];
                cc.w[0] = cint.w[0];
                pow5    = &BID_POWER_FIVE[a as usize];
                cc      = __mul_128x128_low(&cc, pow5);
                return return_bid128(s, 6176 - a, cc.w[1], cc.w[0]);
            }
        }
    }

    // Input exponent can stretch between the maximal and minimal
    // exponents (remembering we force normalization): -16607 <= e <= 16271

    // Compute the estimated decimal exponent e_out; the provisional exponent
    // will be either "e_out" or "e_out-1" depending on later significand check
    // NB: this is the *biased* exponent

    e_plus = e + 42152;
    e_out  = (((19728 * e_plus) + ((19779 * e_plus) >> 16)) >> 16) - 6512;

    // Set up pointers into the bipartite table

    e_hi   = 11232 - e_out;
    e_lo   = e_hi & 127;
    e_hi >>= 7;

    // Look up the inner entry first

    r = BID_INNERTABLE_SIG[e_lo as usize];
    f = BID_INNERTABLE_EXP[e_lo as usize];

    // If we need the other entry, multiply significands and add exponents

    if e_hi != 39 {
        let s_prime: &BID_UINT256 = &BID_OUTERTABLE_SIG[e_hi as usize];
        let t_prime: BID_UINT512;
        f       = f + 256 + BID_OUTERTABLE_EXP[e_hi as usize];
        t_prime = __mul_256x256_to_512(&r, s_prime);
        r.w[0]  = t_prime.w[4] + 1;
        r.w[1]  = t_prime.w[5];
        r.w[2]  = t_prime.w[6];
        r.w[3]  = t_prime.w[7];
    }

    z = __mul_128x256_to_384(&c, &r);

    // Make adjustive shift, ignoring the lower 128 bits

    e = -(241 + e + f);
    srl384_short(&mut z, e);

    // Now test against 10^33 and so decide on adjustment
    // I feel there ought to be a smarter way of doing the multiplication

    if lt128(z.w[5], z.w[4], 54210108624275u64, 4089650035136921600u64) {
        __mul_10x384_to_384(&mut z);
        e_out -= 1;
    }

    // Set up provisional results

    c_prov_hi = z.w[5];
    c_prov_lo = z.w[4];

    // Round using round-sticky words
    // If we spill over into the next decade, correct

    let rb = &BID_ROUNDBOUND_128[(((rnd_mode as u64) << 2) + (((s as u64) & 1) << 1) + (c_prov_lo & 1)) as usize];

    if lt128(rb.w[1], rb.w[0], z.w[3], z.w[2]) {
        c_prov_lo += 1;
        if c_prov_lo == 0 {
            c_prov_hi += 1;
        } else if (c_prov_lo == 4003012203950112768u64)
               && (c_prov_hi == 542101086242752u64) {
            c_prov_hi = 54210108624275u64;
            c_prov_lo = 4089650035136921600u64;
            e_out    += 1;
        }
    }

    // Don't need to check overflow or underflow; however set inexact flag

    if (z.w[3] != 0) || (z.w[2] != 0) {
        __set_status_flags(pfpsf, StatusFlags::BID_INEXACT_EXCEPTION);
    }

    // Package up the result

    return_bid128(s, e_out, c_prov_hi, c_prov_lo)
}